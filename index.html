<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>原告適格・処分性・訴えの利益〇✕暗記アプリ</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  body {
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    margin: 0;
    padding: 0;
    background: #f5f7fb;
    color: #333;
  }
  header {
    background: #0d6efd;
    color: #fff;
    padding: 12px 20px;
  }
  header h1 {
    margin: 0;
    font-size: 1.3rem;
    letter-spacing: 0.1em;
  }
  header p {
    margin: 4px 0 0;
    font-size: 0.85rem;
    opacity: 0.9;
  }

  .container {
    max-width: 1100px;
    margin: 16px auto 30px;
    padding: 0 12px;
  }

  .top-controls {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-bottom: 10px;
    justify-content: space-between;
    align-items: center;
  }

  .btn {
    border: none;
    padding: 8px 14px;
    border-radius: 999px;
    cursor: pointer;
    font-size: 0.85rem;
    background: #e2e8f0;
    transition: transform 0.05s ease, box-shadow 0.1s ease, background 0.2s;
    white-space: nowrap;
  }
  .btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(15, 23, 42, 0.15);
  }
  .btn-outline {
    background: transparent;
    border: 1px solid #cbd5e1;
  }
  .btn[disabled] {
    opacity: 0.4;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
  }

  .tag {
    font-size: 0.75rem;
    padding: 4px 8px;
    border-radius: 999px;
    background: #e0f2fe;
    color: #0369a1;
  }

  .progress-wrapper {
    margin-top: 6px;
  }
  .progress-label {
    font-size: 0.8rem;
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    margin-bottom: 4px;
  }
  .progress-bar {
    width: 100%;
    height: 8px;
    border-radius: 999px;
    background: #e2e8f0;
    overflow: hidden;
  }
  .progress-bar-inner {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, #0d6efd, #22c55e);
    transition: width 0.2s ease;
  }

  .cards {
    display: grid;
    grid-template-columns: minmax(0, 1.25fr) minmax(0, 1fr);
    gap: 16px;
    margin-top: 16px;
  }
  @media (max-width: 900px) {
    .cards {
      grid-template-columns: minmax(0, 1fr);
    }
  }

  .card {
    background: #ffffff;
    border-radius: 18px;
    padding: 16px 18px 18px;
    box-shadow: 0 8px 20px rgba(15, 23, 42, 0.08);
  }

  .card-title {
    font-size: 0.9rem;
    font-weight: 600;
    color: #64748b;
    margin-bottom: 4px;
    display: flex;
    justify-content: space-between;
    gap: 6px;
    align-items: center;
  }
  .question-text {
    font-size: 0.95rem;
    line-height: 1.6;
    white-space: pre-wrap;
  }

  .answer-buttons {
    display: flex;
    gap: 10px;
    margin-top: 16px;
    flex-wrap: wrap;
  }
  .answer-btn {
    flex: 1;
    min-width: 80px;
    font-size: 1.1rem;
    font-weight: 700;
  }
  .answer-btn.correct-choice {
    background: #22c55e;
    color: #fff;
  }
  .answer-btn.wrong-choice {
    background: #ef4444;
    color: #fff;
  }

  .info-row {
    display: flex;
    justify-content: space-between;
    margin-top: 10px;
    font-size: 0.8rem;
    color: #64748b;
    flex-wrap: wrap;
    gap: 4px;
  }

  .feedback {
    margin-top: 10px;
    font-size: 0.9rem;
    font-weight: 600;
  }
  .feedback.correct {
    color: #16a34a;
  }
  .feedback.wrong {
    color: #dc2626;
  }

  .explanation-title {
    font-size: 0.85rem;
    font-weight: 600;
    color: #0f172a;
    margin-bottom: 6px;
  }
  .explanation-body {
    font-size: 0.9rem;
    line-height: 1.6;
    white-space: pre-wrap;
  }

  .pill {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    border-radius: 999px;
    padding: 3px 9px;
    font-size: 0.8rem;
    font-weight: 600;
  }
  .pill-true {
    background: #dcfce7;
    color: #16a34a;
  }
  .pill-false {
    background: #fee2e2;
    color: #b91c1c;
  }

  button:focus {
    outline: none;
  }
  button {
    -webkit-tap-highlight-color: rgba(0,0,0,0);
  }

  html, body {
    overscroll-behavior: contain;
  }

  .header-inner {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 8px;
  }

  .btn-back-main {
    border: none;
    padding: 6px 12px;
    border-radius: 999px;
    font-size: 0.8rem;
    cursor: pointer;
    background: #e2e8f0;
    color: #0f172a;
  }

  .end-screen {
    display: none;
    margin-top: 16px;
    padding: 12px 14px;
    border-radius: 14px;
    background: #eff6ff;
    font-size: 0.9rem;
  }
  .end-screen h2 {
    margin: 0 0 6px;
    font-size: 1rem;
  }
  .end-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 8px;
  }

  .jump-input {
    width: 70px;
    padding: 4px 6px;
    border-radius: 999px;
    border: 1px solid #cbd5e1;
    font-size: 0.8rem;
  }
</style>
</head>
<body>
<script>
  const pass = prompt("パスワードを入力してください：");
  if (pass !== "sug@0") {  // ←ここを好きなパスワードに変えてOK
    alert("パスワードが違います。");
    document.body.innerHTML = "";
  }
</script>
<!-- ここから下は今までのアプリのHTML -->

<header>
  <div class="header-inner">
    <div>
      <h1>原告適格・処分性・訴えの利益　暗記アプリ</h1>
      <p>原文どおりの問題＋判例付き解説</p>
    </div>
    <div>
      <button class="btn-back-main" onclick="location.href='メインアプリ.html'">← メインに戻る</button>
    </div>
  </div>
</header>

<div class="container">

  <div class="top-controls">
    <div style="display:flex; flex-wrap:wrap; gap:8px; align-items:center;">
      <button class="btn btn-outline" id="checkedModeBtn" disabled>チェックした問題だけ出題</button>
      <button class="btn btn-outline" id="retryWrongBtn" disabled>間違えた問題だけ出題</button>
      <button class="btn btn-outline" id="resetBtn">リセット</button>

      <!-- ★ 追加：番号ジャンプ -->
      <div style="display:flex; align-items:center; gap:4px;">
        <input id="jumpInput" class="jump-input" type="number" min="1" placeholder="番号">
        <button class="btn btn-outline" id="jumpBtn">番号へジャンプ</button>
      </div>
    </div>
    <div>
      <span class="tag" id="modeTag">通常モード</span>
    </div>
  </div>

  <div class="progress-wrapper">
    <div class="progress-label">
      <span id="progressText">0 / 0 問</span>
      <span id="scoreText">正解 0 問</span>
    </div>
    <div class="progress-bar">
      <div class="progress-bar-inner" id="progressBarInner"></div>
    </div>
  </div>

  <div class="cards">
    <!-- 左：問題カード -->
    <div class="card">
      <div class="card-title">
        <span id="questionNumber">第 1 問</span>
        <span id="sourceLabel"></span>
      </div>
      <div class="question-text" id="questionText">
        問題を読み込み中…
      </div>

      <div class="answer-buttons">
        <button class="btn answer-btn" id="trueBtn">〇（正しい）</button>
        <button class="btn answer-btn" id="falseBtn">✕（誤り）</button>
      </div>

      <div class="info-row">
        <div>
          <label style="font-size:0.8rem;">
            <input type="checkbox" id="checkCurrent">
            この問題にチェック
          </label>
          <span style="margin-left:8px;">
            正解：<span id="correctMarkPill" class="pill" style="display:none;"></span>
          </span>
        </div>
        <div>
          <button class="btn btn-outline" id="showAnswerBtn">答えを見る</button>
          <button class="btn btn-outline" id="nextBtn">次の問題 ▶</button>
        </div>
      </div>

      <div class="feedback" id="feedback"></div>
    </div>

    <!-- 右：説明カード -->
    <div class="card">
      <div class="card-title">
        <span>解説・メモ</span>
      </div>
      <div class="explanation-title">この問題のポイント</div>
      <div class="explanation-body" id="explanationBody">
        「答えを見る」または〇✕を押すと、ここに解説が表示されます。
      </div>
    </div>
  </div>

  <!-- 終了後の選択画面 -->
  <div class="end-screen" id="endScreen">
    <h2>お疲れさまでした。</h2>
    <div>全問題を解き終わりました。次のモードを選んでください。</div>
    <div class="end-buttons">
      <button class="btn" id="endRetryWrongBtn">間違えた問題だけ出題</button>
      <button class="btn" id="endCheckedModeBtn">チェックした問題だけ出題</button>
      <button class="btn" id="endRestartBtn">最初からやり直す</button>
    </div>
  </div>

</div>

<script>
  // ==== 問題データ ====
  const originalQuestions = [
{
  id: 1,
  question: "林地開発許可処分について、生命・身体に直接的被害を受けるおそれのある周辺住民は、原告適格を有するが、間接的な環境悪化を主張するにすぎない住民は原告適格を有しない。",
  correct: "✕",
  explanation: "最判平13.3.13は、<span style=\"color:#0070C0\">生命・身体への直接的被害のおそれ</span>があれば原告適格を肯定した。しかし、同判例の射程は広く、<span style=\"color:#0070C0\">環境・生活利益も、法令の趣旨に照らし保護される利益に含まれ得る</span>として、間接的な環境悪化を主張する住民についても、法令の趣旨によっては原告適格が肯定され得る。"
},
{
  id: 2,
  question: "総合設計許可処分において、建築物の倒壊・炎上などの直接的被害のおそれが想定される範囲の建物の居住者のみが原告適格を有し、日照阻害のみを主張する者は原告適格を有しない。",
  correct: "✕",
  explanation: "最判平14.1.22は、倒壊・炎上等の直接的被害のおそれに基づき原告適格を肯定した。その後、最判平14.3.28は、<span style=\"color:#0070C0\">日照阻害</span>についても建築基準法の趣旨に照らし保護される利益に当たるとして原告適格を肯定した。したがって日照阻害を理由とする住民にも原告適格が認められる。"
},
{
  id: 3,
  question: "風俗営業許可処分について、周辺住民は原告適格を有するが、営業を予定する店舗から500m以上離れた住民は原告適格を有しないとされる。",
  correct: "✕",
  explanation: "最判平10.12.17は、<span style=\"color:#0070C0\">風俗営業による生活環境の悪化</span>という利益は法的に保護された利益に当たるとした。ただし、距離のみで画一的に線引きするのではなく、<span style=\"color:#0070C0\">具体的事案に応じて生活環境への被害可能性を総合考慮</span>すべきである。"
},
{
  id: 4,
  question: "都市計画決定（用途地域の指定）は、処分性を有しないため、これに対しては取消訴訟を提起できない。",
  correct: "〇",
  explanation: "最判昭57.4.22は、<span style=\"color:#0070C0\">用途地域指定は一般的・抽象的規範定立行為</span>であり、特定の者の権利義務を直接形成するものではないとして、処分性を否定した。"
},
{
  id: 5,
  question: "第二種市街地再開発事業計画の決定は、処分性を有しない。",
  correct: "✕",
  explanation: "最判平4.11.26は、第二種市街地再開発事業計画の決定は、<span style=\"color:#0070C0\">個々の権利義務形成に密接に関連する具体的行為</span>として処分性を肯定した。"
},
{
  id: 6,
  question: "輸入禁止品該当品の通知は、処分性のない事実行為である。",
  correct: "✕",
  explanation: "最判昭51.12.25は、輸入禁止品該当品の通知について、<span style=\"color:#0070C0\">法的効果を直接もたらす行為</span>として処分性を肯定した。"
},
{
  id: 7,
  question: "自治体の条例による道路料金改定は、規範定立行為であるため、処分性が認められない。",
  correct: "〇",
  explanation: "最判昭28.2.2等は、条例の制定・改廃は<span style=\"color:#0070C0\">一般的抽象的規範</span>の定立であり、特定の者に対する法的効果を直接形成しないため、処分性は否定される。"
},
{
  id: 8,
  question: "建築基準法42条2項の道路指定が告示により一括してされた場合は、処分性が否定される。",
  correct: "✕",
  explanation: "最判昭41.1.17等は、道路指定は個々の土地の建築可否に直接影響するため、<span style=\"color:#0070C0\">個別具体的な法的効果</span>を有するとして処分性を肯定した。"
},
{
  id: 9,
  question: "反則金納付の告知は、法的効果を生じさせる処分であり、取消訴訟の対象となる。",
  correct: "✕",
  explanation: "最判昭57.7.15は、反則金告知は<span style=\"color:#0070C0\">任意処分（行政上の選択肢の提示）</span>に過ぎず、法的効果を直接形成するものではないとして処分性を否定した。"
},
{
  id: 10,
  question: "市町村長が住民票に世帯主との続柄を記載する行為は、処分性が認められる。",
  correct: "✕",
  explanation: "最判平11.1.21は、住民票記載行為は<span style=\"color:#0070C0\">事務処理行為（確認行為）</span>であり、権利義務に直接影響を与えないため処分性は否定される。"
},
{
  id: 11,
  question: "皇居外苑使用不許可処分は、使用期間が経過した後でも、訴えの利益は存続する。",
  correct: "✕",
  explanation: "最大判平28.12.23は、使用期間が経過し、<span style=\"color:#0070C0\">原状に回復できない場合</span>には、訴えの利益が失われるとした。"
},
{
  id: 12,
  question: "運転免許取消処分について、免許の有効期間が経過した場合でも、処分の違法性を争う訴えの利益は肯定される。",
  correct: "〇",
  explanation: "最判昭40.8.2は、免許の効力が失われても、<span style=\"color:#0070C0\">欠格期間などの法的効果が残存する</span>ため、訴えの利益を肯定した。"
},
{
  id: 13,
  question: "運転免許停止処分について、停止期間が経過した場合には、原則として訴えの利益は消滅する。",
  correct: "〇",
  explanation: "最判昭55.11.25は、停止期間経過により<span style=\"color:#0070C0\">法的効果が消滅</span>しているため、原則として訴えの利益は否定される。"
},
{
  id: 14,
  question: "建築確認処分は、建築工事が完了した後でも、原則として訴えの利益が残存する。",
  correct: "✕",
  explanation: "最判昭59.10.26は、建築工事が完了し、<span style=\"color:#0070C0\">原状回復が不可能</span>であるため、訴えの利益を否定した。"
},
{
  id: 15,
  question: "土地区画整理事業の施行認可処分について、工事が完了し換地処分もされ原状回復が不可能となった場合には、取消しても法律上の利益が回復し得ず、訴えの利益は否定される。",
  correct: "〇",
  explanation: "最判平成4年1月24日は、工事完了・換地処分済みにより<span style=\"color:#0070C0\">取消しても原状回復できず実益がない</span>として訴えの利益を否定した。しかし、工事未了や換地前など、<span style=\"color:#0070C0\">取消によりなお法的利益が残る場合には訴えの利益が肯定され得る</span>点に注意が必要である。"
},
{
  id: 16,
  question: "生活保護変更決定処分について、原告本人が死亡した場合には、生活保護による利益は消滅し、原則として訴えの利益は失われる。",
  correct: "〇",
  explanation: "生活保護は本人の生活維持を目的とする制度であり、最判昭42.5.24は、<span style=\"color:#0070C0\">本人死亡により生活保護の給付を受ける利益は消滅</span>するとして訴えの利益を否定した。公務員免職のように<span style=\"color:#0070C0\">名誉回復の利益が残る類型ではない</span>点が重要である。"
},
{
  id: 17,
  question: "公務員免職処分について、原告公務員が死亡した場合には、訴えの利益は当然に消滅する。",
  correct: "✕",
  explanation: "最判昭49.12.10は、免職処分は社会的評価に影響するため、<span style=\"color:#0070C0\">名誉回復の利益</span>が残り、訴えの利益を肯定した。"
},
{
  id: 18,
  question: "保安林指定解除処分について、解除後に行われた伐採等により原状回復が不可能となった場合には、取消しても法的実益がなく、訴えの利益は失われる。",
  correct: "〇",
  explanation: "最判昭57.9.9は、保安林指定解除後に伐採等が進み<span style=\"color:#0070C0\">原状回復が不可能</span>となった場合、取消しても保安林としての規制状態を回復し得ず、<span style=\"color:#0070C0\">訴えの利益は否定される</span>とした。"
},
{
  id: 19,
  question: "再入国不許可処分について、原告がすでに出国して在留資格を喪失している場合には、処分を取消しても再入国の法的地位は回復しないため、訴えの利益は失われる。",
  correct: "〇",
  explanation: "最判平10.4.10は、原告が<span style=\"color:#0070C0\">出国後に在留資格を喪失</span>した場合、取消しても再入国できる法的地位は復活しないとして、<span style=\"color:#0070C0\">訴えの利益を否定</span>した。"
},
{
  id: 20,
  question: "公文書非公開決定について、対象文書が後に書証として提出された場合でも、訴えの利益はなお存続し得る。",
  correct: "〇",
  explanation: "最判平14.2.28は、公開の有無についての<span style=\"color:#0070C0\">確認利益</span>が残るとして訴えの利益を肯定した。"
},
{
  id: 21,
  question: "公務員免職処分の取消訴訟では、原告が処分後に公職へ再就職した場合、訴えの利益は失われる。",
  correct: "✕",
  explanation: "最大判昭40.4.28は、<span style=\"color:#0070C0\">名誉回復の利益</span>が残存するため、訴えの利益を肯定した。"
},
{
  id: 22,
  question: "運転免許更新拒否処分について、原告が後日新たな免許を取得した場合には、訴えの利益が消滅する。",
  correct: "✕",
  explanation: "最判平21.2.27は、新たな免許取得後でも、<span style=\"color:#0070C0\">過去の違法処分の取消しによる効果</span>が残るとして訴えの利益を肯定した。"
},
{
  id: 23,
  question: "事実行為は原則として処分性を有しないが、実質的に法的効果を生じる場合には処分性が肯定され得る。",
  correct: "〇",
  explanation: "判例（輸入禁止品該当通知など）は、<span style=\"color:#0070C0\">実質的法効果基準</span>に基づき、形式にとらわれず処分性を判断している。"
},
{
  id: 24,
  question: "原告適格は、当該法令が保護しようとする利益の内容と性質に照らして判断されるべきであり、原告が主張する利益が事実上の利益にすぎない場合は、直ちに原告適格が否定される。",
  correct: "✕",
  explanation: "<span style=\"color:#0070C0\">法令の趣旨により保護される利益</span>であれば、事実上の利益と評価される利益でも原告適格が肯定され得る（例：環境利益）。"
},
{
  id: 25,
  question: "取消訴訟の利益は、処分の違法性を訴える人格的利益が認められる限り、常に認められる。",
  correct: "✕",
  explanation: "人格的利益があっても、<span style=\"color:#0070C0\">取消しにより具体的な法律効果が回復可能であるか</span>が必要であり、単なる抽象的名誉回復のみでは否定される場合もある。"
},
{
  id: 26,
  question: "行政事件訴訟法9条1項ただし書は、原告適格を拡張する方向に解されており、判例も一貫して緩和的に運用している。",
  correct: "〇",
  explanation: "2004年改正以降、<span style=\"color:#0070C0\">「法律上の利益」＝保護に値する個別的利益</span>の観点が重視され、原告適格は緩和的に認められている（林地開発・総合設計など）。"
},
{
  id: 27,
  question: "行政計画は一般的に処分性を有しないが、特定人に具体的な義務を課すものであれば処分性が認められることがある。",
  correct: "〇",
  explanation: "判例（第二種市街地再開発計画など）は、<span style=\"color:#0070C0\">行政計画であっても個別具体的な法的効果</span>があれば処分性を肯定している。"
},
{
  id: 28,
  question: "取消訴訟では、処分時の事情のみならず、訴訟係属中の事情変更も考慮して訴えの利益を判断する。",
  correct: "〇",
  explanation: "訴えの利益は、<span style=\"color:#0070C0\">判決時の事情</span>に基づいて判断される（処分の効果の消滅、事情変更など）。"
},
{
  id: 29,
  question: "原告適格の判断において、具体的危険の主張がない住民は、常に適格を欠くとされる。",
  correct: "✕",
  explanation: "近時判例は、<span style=\"color:#0070C0\">環境・安全利益</span>について、抽象的危険の主張でも法令の趣旨に照らし保護される利益なら原告適格を認める傾向にある。"
},
{
  id: 30,
  question: "取消訴訟の適法性判断は、処分性 → 原告適格 → 訴えの利益の順に判断され、いずれかが欠ければ不適法却下となる。",
  correct: "〇",
  explanation: "行政事件訴訟法における適法性判断は、<span style=\"color:#0070C0\">処分性・原告適格・訴えの利益（救済必要性）</span>が三本柱であり、いずれも必要である。"
},
{
  id: 31,
  question: "質屋営業許可処分について、既存の質屋営業者は、新たな質屋営業許可の取消訴訟を提起する原告適格を有するとするのが判例である。",
  correct: "✕",
  explanation: "最判昭34.8.18は、質屋営業許可制度の趣旨は、質屋営業の適正な運営と利用者保護にあり、<span style=\"color:#0070C0\">既存営業者の営業上の競争利益は法が個別的に保護する利益ではない</span>として、原告適格を否定した。"
},
{
  id: 32,
  question: "公衆浴場営業許可処分について、既存の公衆浴場営業者は、新たな許可の取消訴訟につき、営業上の利益に基づく原告適格を有する。",
  correct: "〇",
  explanation: "公衆浴場法は、地域住民の衛生・入浴機会確保の観点から、<span style=\"color:#0070C0\">適正な数・配置の公衆浴場を維持すること</span>を目的としている。その結果、既存営業者の営業継続も法の趣旨と密接に結びつき、判例は<span style=\"color:#0070C0\">既存営業者の営業上の利益を法律上保護された利益</span>として原告適格を肯定する。"
},
{
  id: 33,
  question: "史跡指定解除処分について、その史跡を研究対象としてきた学術研究者は、学問研究の自由に基づき、原告適格を有すると判例は判示している。",
  correct: "✕",
  explanation: "史跡指定・解除に関する制度は、文化財の保護という<span style=\"color:#0070C0\">一般的公益</span>を目的とするものであり、個々の研究者の学術上の関心・便宜までは法が個別的に保護する利益とはいえない。したがって、判例は<span style=\"color:#0070C0\">学術研究者の原告適格を否定</span>している。"
},
{
  id: 34,
  question: "清涼飲料水のジュース表示に関する規格認定処分について、当該飲料を購入し消費する消費者は、『誤認防止』という観点から原告適格を有すると判例は判示している。",
  correct: "✕",
  explanation: "ジュース表示規格認定制度は、取引の公正や一般消費者の誤認防止など<span style=\"color:#0070C0\">一般的な消費者保護</span>を目的とするが、判例はこれをもって個々の消費者に<span style=\"color:#0070C0\">具体的な法律上の利益</span>を付与したものではないとして、原告適格を否定している。"
},
{
  id: 35,
  question: "鉄道の特急料金認可処分について、特急列車の利用者は、料金水準の適否に関する法律上の利益を有するため、原告適格を有すると判例は判示している。",
  correct: "✕",
  explanation: "特急料金認可は、運輸政策上の判断に属するものであり、料金水準は広く公共政策的に決定される。判例は、<span style=\"color:#0070C0\">個々の利用者の経済的負担軽減</span>を直接に保護しようとする趣旨ではないとして、利用者の原告適格を否定している。"
},
{
  id: 36,
  question: "医療廃棄物焼却施設の設置許可処分について、その施設に廃棄物処理を委託している医療機関は原告適格を有し、周辺の一般住民は原告適格を有しないとするのが判例である。",
  correct: "〇",
  explanation: "医療廃棄物焼却施設の許可制度は、主として<span style=\"color:#0070C0\">適正な廃棄物処理と医療提供体制の維持</span>を目的とし、許可の相手方たる医療機関の処理委託関係は法の趣旨と密接に結びつく。他方、周辺住民の生活環境一般は、当該法令の直接の保護対象とはされておらず、判例は<span style=\"color:#0070C0\">医療機関の原告適格のみを肯定し、住民の原告適格を否定</span>している。"
},
{
  id: 37,
  question: "定期航空運送事業免許処分について、航空機騒音により生命・身体に具体的な危険が及ぶおそれのある周辺住民は、原告適格を有すると判例は認めている。",
  correct: "〇",
  explanation: "判例は、航空機騒音により<span style=\"color:#0070C0\">睡眠妨害・健康被害</span>等の具体的危険が生ずるおそれのある地域住民について、航空法等の規制が<span style=\"color:#0070C0\">生命・身体の安全利益</span>を保護する趣旨を有すると解し、原告適格を肯定している。"
},
{
  id: 38,
  question: "都市計画事業認可処分について、その事業により騒音や振動などの被害を直接受けるおそれのある周辺住民は、原告適格を有すると判例は解している。",
  correct: "〇",
  explanation: "道路・鉄道等の都市計画事業は、周辺住民の<span style=\"color:#0070C0\">生命・身体の安全や生活環境</span>に重大な影響を与え得る。判例は、関係法令の趣旨に照らし、かかる住民の利益を<span style=\"color:#0070C0\">法律上保護された個別的利益</span>と捉え、原告適格を肯定している。"
},
{
  id: 39,
  question: "供託官が供託金の還付請求を拒否する旨の告下を行った場合、その告下は行政処分であり、取消訴訟の対象となる。",
  correct: "〇",
  explanation: "供託官の告下は、<span style=\"color:#0070C0\">供託金の還付を認めないという法的効果</span>を直接生じさせ、供託者の権利に直接影響を与える。このように、特定の者の権利義務を直接形成・確定する行為は、判例上<span style=\"color:#0070C0\">処分性が肯定</span>され、取消訴訟の対象となる。"
},
{
  id: 40,
  question: "国有財産法に基づく国有地の払下げ行為は、国が優越的地位から行う公法上の行為であり、処分性が認められる。",
  correct: "✕",
  explanation: "判例は、国有地の払下げ契約は、国が私人と<span style=\"color:#0070C0\">対等な立場</span>で締結する売買契約にすぎず、私人間の売買と本質的に異ならないとする。そのため、これは<span style=\"color:#0070C0\">私法上の行為</span>であって、行政事件訴訟法上の処分には当たらないと解されている。"
},
{
  id: 41,
  question: "建築確認に先立ち必要とされる消防長の同意行為や、上級行政庁が発する一般的な通達は、いずれも内部的行為であり、通常は処分性が否定される。",
  correct: "〇",
  explanation: "消防長の同意は、建築確認という最終的な処分の前提となる<span style=\"color:#0070C0\">内部的・補充的判断</span>にとどまり、通達も下級行政庁に対する<span style=\"color:#0070C0\">内部的な指示・解釈指針</span>にすぎない。いずれも、直接私人の権利義務を形成するものではないため、判例は原則として処分性を否定している。"
},
{
  id: 42,
  question: "簡易水道料金条例の改正（料金額の改定）は、一般的・抽象的な規範定立行為であり、特定の者の権利義務を直接形成しないから、処分性は否定される。",
  correct: "〇",
  explanation: "料金条例の制定・改正は、<span style=\"color:#0070C0\">将来の個々の料金徴収の根拠</span>を一般的・抽象的に定めるものであり、特定の者に対して直接具体的な法律効果を発生させるものではない。したがって、判例は<span style=\"color:#0070C0\">規範定立行為として処分性を否定</span>している。"
},
{
  id: 43,
  question: "市街化調整区域内における開発許可処分について、許可に基づく建築工事が終了し検査済証が交付された後であっても、なお取消訴訟の訴えの利益が肯定された判例がある。",
  correct: "〇",
  explanation: "市街化調整区域内の開発許可は、当該土地の<span style=\"color:#0070C0\">土地利用の性格付け</span>に長期的影響を及ぼすため、工事完了後・検査済証交付後であっても、将来の増改築等に関する<span style=\"color:#0070C0\">法的地位の確認</span>などの点で実益が残ると判示された事例がある。このように、判例は処分後の事情も踏まえつつ<span style=\"color:#0070C0\">訴えの利益を柔軟に肯定</span>している。"
},
{
  id: 44,
  question: "公務員免職処分を受けた者が、その後に昇任等により地位回復をした場合や、運転免許更新拒否処分を受けた者がその後新たな免許を取得した場合であっても、処分の違法を争う訴えの利益が認められることがある。",
  correct: "〇",
  explanation: "行政事件訴訟法9条1項ただし書は、<span style=\"color:#0070C0\">処分の取消しによりなお回復すべき利益</span>がある限り訴えの利益を認める趣旨と解される。判例は、公務員免職の後の昇任や、新たな免許取得後であっても、<span style=\"color:#0070C0\">名誉回復・過去の処分履歴の影響</span>等から訴えの利益を肯定する余地があることを認めている。"
},
{
  id: 45,
  question: "取消訴訟の適法性判断においては、処分性・原告適格・訴えの利益は相互に独立した要件であり、いずれか1つが欠ければ他の2つを満たしていても不適法却下となる。",
  correct: "〇",
  explanation: "行政事件訴訟法上の取消訴訟は、<span style=\"color:#0070C0\">①行政上の処分であること（処分性）</span>、<span style=\"color:#0070C0\">②当該処分について法律上の利益を有する者であること（原告適格）</span>、<span style=\"color:#0070C0\">③判決時においてなお取消しによる具体的実益が存在すること（訴えの利益）</span>の3要件を充たす必要がある。いずれかが欠ければ、訴えは不適法として却下される。"
},


  ];

  const STORAGE_KEY = "ankini_genkoku_v1";

  let questions = [];
  let currentIndex = 0;
  let answeredCount = 0;
  let correctCount = 0;
  let wrongIds = new Set();
  let checkedIds = new Set();
  let mode = "normal"; // normal / wrongOnly / checkedOnly
  let hasAnsweredCurrent = false;

  const questionNumberEl = document.getElementById("questionNumber");
  const questionTextEl = document.getElementById("questionText");
  const sourceLabelEl = document.getElementById("sourceLabel");
  const explanationBodyEl = document.getElementById("explanationBody");
  const trueBtn = document.getElementById("trueBtn");
  const falseBtn = document.getElementById("falseBtn");
  const showAnswerBtn = document.getElementById("showAnswerBtn");
  const nextBtn = document.getElementById("nextBtn");
  const feedbackEl = document.getElementById("feedback");
  const progressTextEl = document.getElementById("progressText");
  const scoreTextEl = document.getElementById("scoreText");
  const progressBarInnerEl = document.getElementById("progressBarInner");
  const checkedModeBtn = document.getElementById("checkedModeBtn");
  const retryWrongBtn = document.getElementById("retryWrongBtn");
  const resetBtn = document.getElementById("resetBtn");
  const modeTagEl = document.getElementById("modeTag");
  const correctMarkPillEl = document.getElementById("correctMarkPill");
  const checkCurrentEl = document.getElementById("checkCurrent");
  const endScreenEl = document.getElementById("endScreen");
  const endRetryWrongBtn = document.getElementById("endRetryWrongBtn");
  const endCheckedModeBtn = document.getElementById("endCheckedModeBtn");
  const endRestartBtn = document.getElementById("endRestartBtn");

  // ★ 追加：ジャンプ用
  const jumpInputEl = document.getElementById("jumpInput");
  const jumpBtnEl = document.getElementById("jumpBtn");

  function saveState() {
    try {
      if (questions.length === 0) return;
      const q = questions[currentIndex];
      const state = {
        mode,
        currentQuestionId: q.id,
        wrongIds: Array.from(wrongIds),
        checkedIds: Array.from(checkedIds),
        answeredCount,
        correctCount
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    } catch (e) {
      console.warn("状態の保存に失敗しました", e);
    }
  }

  function loadState() {
    try {
      const s = localStorage.getItem(STORAGE_KEY);
      if (!s) return null;
      return JSON.parse(s);
    } catch (e) {
      console.warn("状態の読み込みに失敗しました", e);
      return null;
    }
  }

  function updateModeButtons() {
    retryWrongBtn.disabled = wrongIds.size === 0;
    checkedModeBtn.disabled = checkedIds.size === 0;
  }

  function hideEndScreen() {
    endScreenEl.style.display = "none";
  }
  function showEndScreen() {
    endScreenEl.style.display = "block";
  }

  function loadQuestion() {
    if (questions.length === 0) {
      questionTextEl.textContent = "問題データがありません。";
      return;
    }
    const q = questions[currentIndex];
    questionNumberEl.textContent = `第 ${currentIndex + 1} 問`;

    questionTextEl.innerHTML = q.question;
    sourceLabelEl.textContent = q.source ? q.source : "";
    explanationBodyEl.innerHTML = "「答えを見る」または〇✕を押すと、ここに解説が表示されます。";

    feedbackEl.textContent = "";
    feedbackEl.className = "feedback";
    hasAnsweredCurrent = false;

    checkCurrentEl.checked = checkedIds.has(q.id);

    correctMarkPillEl.style.display = "none";
    correctMarkPillEl.className = "pill";
    correctMarkPillEl.textContent = "";

    trueBtn.classList.remove("correct-choice", "wrong-choice");
    falseBtn.classList.remove("correct-choice", "wrong-choice");

    hideEndScreen();
  }

  function updateProgress() {
    const total = questions.length;
    progressTextEl.textContent = `${answeredCount} / ${total} 問`;
    scoreTextEl.textContent = `正解 ${correctCount} 問`;
    const ratio = total > 0 ? (answeredCount / total) * 100 : 0;
    progressBarInnerEl.style.width = `${ratio}%`;
  }

  function showCorrectMark(q) {
    correctMarkPillEl.style.display = "inline-flex";
    if (q.correct === "〇") {
      correctMarkPillEl.className = "pill pill-true";
      correctMarkPillEl.textContent = "正解：〇";
    } else {
      correctMarkPillEl.className = "pill pill-false";
      correctMarkPillEl.textContent = "正解：✕";
    }
  }

  function updateModeTag() {
    if (mode === "wrongOnly") {
      modeTagEl.textContent = "間違えた問題モード";
      modeTagEl.style.background = "#fee2e2";
      modeTagEl.style.color = "#b91c1c";
    } else if (mode === "checkedOnly") {
      modeTagEl.textContent = "チェック問題モード";
      modeTagEl.style.background = "#fef3c7";
      modeTagEl.style.color = "#92400e";
    } else {
      modeTagEl.textContent = "通常モード";
      modeTagEl.style.background = "#e0f2fe";
      modeTagEl.style.color = "#0369a1";
    }
  }

  function handleAnswer(choice) {
    if (questions.length === 0) return;
    const q = questions[currentIndex];

    if (!hasAnsweredCurrent) {
      answeredCount++;
      if (choice === q.correct) {
        correctCount++;
        wrongIds.delete(q.id);
      } else {
        wrongIds.add(q.id);
      }
      hasAnsweredCurrent = true;
      updateProgress();
      updateModeButtons();
      saveState();
    }

    const isCorrect = choice === q.correct;

    trueBtn.classList.remove("correct-choice", "wrong-choice");
    falseBtn.classList.remove("correct-choice", "wrong-choice");

    if (choice === "〇") {
      trueBtn.classList.add(isCorrect ? "correct-choice" : "wrong-choice");
    } else {
      falseBtn.classList.add(isCorrect ? "correct-choice" : "wrong-choice");
    }

    feedbackEl.textContent = isCorrect ? "正解！" : "不正解…";
    feedbackEl.className = "feedback " + (isCorrect ? "correct" : "wrong");

    explanationBodyEl.innerHTML = q.explanation || "（解説が未登録です）";
    showCorrectMark(q);
  }

  function showAnswerOnly() {
    if (questions.length === 0) return;
    const q = questions[currentIndex];
    explanationBodyEl.innerHTML = q.explanation || "（解説が未登録です）";
    feedbackEl.textContent = "答えを表示しました。";
    feedbackEl.className = "feedback";
    showCorrectMark(q);

    trueBtn.classList.remove("correct-choice", "wrong-choice");
    falseBtn.classList.remove("correct-choice", "wrong-choice");
  }

  function goNext() {
    if (questions.length === 0) return;

    // 全問回答済みなら「お疲れさまでした」を表示
    if (answeredCount >= questions.length) {
      showEndScreen();
      return;
    }

    currentIndex++;
    if (currentIndex >= questions.length) {
      currentIndex = 0;
    }
    loadQuestion();
    saveState();
  }

  function resetAll() {
    mode = "normal";
    updateModeTag();

    answeredCount = 0;
    correctCount = 0;
    wrongIds.clear();
    checkedIds.clear();
    questions = originalQuestions.slice();
    currentIndex = 0;
    updateProgress();
    updateModeButtons();
    hideEndScreen();
    try {
      localStorage.removeItem(STORAGE_KEY);
    } catch (e) {}
    loadQuestion();
  }

  function switchToWrongOnly() {
    if (wrongIds.size === 0) return;
    mode = "wrongOnly";
    answeredCount = 0;
    correctCount = 0;
    questions = originalQuestions.filter(q => wrongIds.has(q.id));
    if (questions.length === 0) {
      questions = originalQuestions.slice();
      mode = "normal";
    }
    currentIndex = 0;
    updateProgress();
    updateModeButtons();
    updateModeTag();
    hideEndScreen();
    saveState();
    loadQuestion();
  }

  function switchToCheckedOnly() {
    if (checkedIds.size === 0) return;
    mode = "checkedOnly";
    answeredCount = 0;
    correctCount = 0;
    questions = originalQuestions.filter(q => checkedIds.has(q.id));
    if (questions.length === 0) {
      questions = originalQuestions.slice();
      mode = "normal";
    }
    currentIndex = 0;
    updateProgress();
    updateModeButtons();
    updateModeTag();
    hideEndScreen();
    saveState();
    loadQuestion();
  }

  function restartNormalFromBeginning() {
    mode = "normal";
    answeredCount = 0;
    correctCount = 0;
    questions = originalQuestions.slice();
    currentIndex = 0;
    updateProgress();
    updateModeButtons();
    updateModeTag();
    hideEndScreen();
    saveState();
    loadQuestion();
  }

  // ★ 追加：番号ジャンプ（id で探す）
  function jumpToQuestion() {
    if (!jumpInputEl) return;
    const value = jumpInputEl.value.trim();
    if (value === "") return;
    const num = Number(value);
    if (!Number.isInteger(num) || num <= 0) {
      alert("正しい問題番号（1以上の整数）を入力してください。");
      return;
    }
    // 今のモードで使っている questions の中から、id が一致するものを探す
    const idx = questions.findIndex(q => q.id === num);
    if (idx === -1) {
      alert("現在のモードに、その番号の問題はありません。");
      return;
    }
    currentIndex = idx;
    loadQuestion();
    saveState();
  }

  checkCurrentEl.addEventListener("change", () => {
    if (questions.length === 0) return;
    const q = questions[currentIndex];
    if (checkCurrentEl.checked) {
      checkedIds.add(q.id);
    } else {
      checkedIds.delete(q.id);
    }
    updateModeButtons();
    saveState();
  });

  trueBtn.addEventListener("click", () => handleAnswer("〇"));
  falseBtn.addEventListener("click", () => handleAnswer("✕"));
  showAnswerBtn.addEventListener("click", showAnswerOnly);
  nextBtn.addEventListener("click", goNext);
  resetBtn.addEventListener("click", resetAll);
  retryWrongBtn.addEventListener("click", switchToWrongOnly);
  checkedModeBtn.addEventListener("click", switchToCheckedOnly);

  endRetryWrongBtn.addEventListener("click", switchToWrongOnly);
  endCheckedModeBtn.addEventListener("click", switchToCheckedOnly);
  endRestartBtn.addEventListener("click", restartNormalFromBeginning);

  // ★ ジャンプボタン＆Enterキー
  jumpBtnEl.addEventListener("click", jumpToQuestion);
  jumpInputEl.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      jumpToQuestion();
    }
  });

  (function init() {
    questions = originalQuestions.slice();

    const state = loadState();
    if (state && state.currentQuestionId != null) {
      wrongIds = new Set(Array.isArray(state.wrongIds) ? state.wrongIds : []);
      checkedIds = new Set(Array.isArray(state.checkedIds) ? state.checkedIds : []);
      answeredCount = typeof state.answeredCount === "number" ? state.answeredCount : 0;
      correctCount  = typeof state.correctCount  === "number" ? state.correctCount  : 0;
      mode = state.mode || "normal";
      updateModeTag();

      if (mode === "wrongOnly") {
        questions = originalQuestions.filter(q => wrongIds.has(q.id));
      } else if (mode === "checkedOnly") {
        questions = originalQuestions.filter(q => checkedIds.has(q.id));
      } else {
        questions = originalQuestions.slice();
      }
      if (questions.length === 0) {
        questions = originalQuestions.slice();
        mode = "normal";
        updateModeTag();
      }
      const idx = questions.findIndex(q => q.id === state.currentQuestionId);
      currentIndex = idx >= 0 ? idx : 0;
    } else {
      mode = "normal";
      updateModeTag();
      answeredCount = 0;
      correctCount = 0;
      wrongIds.clear();
      checkedIds.clear();
      questions = originalQuestions.slice();
      currentIndex = 0;
    }

    updateProgress();
    updateModeButtons();
    loadQuestion();
  })();
</script>

</body>
</html>


